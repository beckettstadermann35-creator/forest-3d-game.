<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Forest Wendigo — Three.js</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; }
    #overlay {
      position: absolute; top: 12px; left: 12px; z-index: 10; color: #dfe; background: rgba(0,0,0,0.35);
      padding: 10px 12px; border-radius: 8px; backdrop-filter: blur(4px); max-width: 320px;
    }
    #hint { font-size:13px; opacity:.9; }
    #title { font-weight:700; font-size:16px; margin-bottom:6px; }
    #instructions { font-size:13px; margin-top:8px; }
    #status { position: absolute; right: 12px; bottom: 12px; z-index: 10; color: #f88; background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; }
    canvas { display:block; }
    .bigflash {
      position:absolute; inset:0; background:#fff; z-index:9999; opacity:0; pointer-events:none;
      transition: opacity 0.2s ease-out;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="title">Forest Wendigo — Three.js (first-person)</div>
    <div id="hint">Click the view to lock pointer. WASD to move. Mouse to look.</div>
    <div id="instructions">Objective: survive. If the Wendigo sees you, it chases. Use trees to hide and keep moving.</div>
  </div>
  <div id="status" aria-live="polite">Status: Exploring</div>
  <div id="flash" class="bigflash"></div>

  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
  import { PointerLockControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/PointerLockControls.js';

  // Scene basic
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x101218, 0.025);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x0e1114);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xcfe8ff, 0x242a2f, 0.65);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff6e0, 0.6);
  dir.position.set(-5, 10, 5);
  scene.add(dir);

  // Ground
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x24331f, roughness:1, metalness:0 });
  const groundGeo = new THREE.PlaneGeometry(400, 400);
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Basic ambient wind sound using WebAudio oscillator + noise for gentle wind
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function makeWind() {
    // noise buffer
    const bufferSize = 2 * audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * 0.2;
    const noise = audioCtx.createBufferSource(); noise.buffer = buffer; noise.loop = true;
    const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
    const gain = audioCtx.createGain(); gain.gain.value = 0.06; // quiet ambient
    noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
    noise.start();
    return { noise, gain };
  }
  const wind = makeWind();

  // Create simple low-poly trees
  const treeCount = 120;
  const trees = new THREE.Group();
  scene.add(trees);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3322 });
  const leafMat = new THREE.MeshStandardMaterial({ color: 0x1f3a1a, flatShading:true });
  const rand = (a,b)=> a + Math.random()*(b-a);

  for (let i=0;i<treeCount;i++){
    const trunk = new THREE.CylinderGeometry(rand(0.08,0.18), rand(0.08,0.2), rand(1.5,3.5), 6);
    const trunkMesh = new THREE.Mesh(trunk, trunkMat);
    const cone = new THREE.ConeGeometry(rand(0.6,1.6), rand(1.2,2.6), 6);
    const coneMesh = new THREE.Mesh(cone, leafMat);
    const tree = new THREE.Group();
    tree.add(trunkMesh);
    coneMesh.position.y = trunkMesh.geometry.parameters.height/2 + coneMesh.geometry.parameters.height/2 - 0.2;
    tree.add(coneMesh);
    const dist = rand(8, 160);
    const angle = Math.random()*Math.PI*2;
    tree.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
    tree.rotation.y = Math.random()*Math.PI;
    const s = rand(0.7,1.6);
    tree.scale.set(s,s,s);
    trees.add(tree);
  }

  // Add subtle wind sway to trees
  function swayTrees(time){
    trees.children.forEach((t, i)=>{
      t.rotation.z = Math.sin(time*0.0005 + i)*0.02;
      t.rotation.x = Math.cos(time*0.0003 + i)*0.01;
    });
  }

  // Player controls (PointerLockControls)
  const controls = new PointerLockControls(camera, renderer.domElement);
  const onClickToStart = () => {
    controls.lock();
    // resume audio context when user interacts
    if (audioCtx.state === 'suspended') audioCtx.resume();
  };
  renderer.domElement.addEventListener('click', onClickToStart);

  controls.addEventListener('lock', ()=> {
    document.getElementById('overlay').style.display = 'none';
  });
  controls.addEventListener('unlock', ()=> {
    document.getElementById('overlay').style.display = 'block';
  });

  // Movement state
  const move = { forward:false, back:false, left:false, right:false };
  let velocity = new THREE.Vector3();
  let canMove = true;
  const speed = 5.0; // m/s

  document.addEventListener('keydown', (e)=>{
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.back = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
  });
  document.addEventListener('keyup', (e)=>{
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.back = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
  });

  // Low-poly Wendigo made from primitives
  function buildWendigo() {
    const g = new THREE.Group();

    // body
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b, metalness:0.1, roughness:0.9 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.4,0.5), bodyMat);
    body.position.y = 1.1;
    g.add(body);

    // limbs
    const limbGeom = new THREE.CylinderGeometry(0.08,0.08,1.0,6);
    const leftArm = new THREE.Mesh(limbGeom, bodyMat); leftArm.position.set(-0.7,1.0,0); leftArm.rotation.z = 0.2;
    const rightArm = new THREE.Mesh(limbGeom, bodyMat); rightArm.position.set(0.7,1.0,0); rightArm.rotation.z = -0.2;
    leftArm.geometry.translate(0, -0.5, 0);
    rightArm.geometry.translate(0, -0.5, 0);
    g.add(leftArm, rightArm);

    const legGeom = new THREE.CylinderGeometry(0.09,0.09,1.1,6);
    const leftLeg = new THREE.Mesh(legGeom, bodyMat); leftLeg.position.set(-0.25,0.2,0); leftLeg.geometry.translate(0, -0.55, 0);
    const rightLeg = new THREE.Mesh(legGeom, bodyMat); rightLeg.position.set(0.25,0.2,0); rightLeg.geometry.translate(0, -0.55, 0);
    g.add(leftLeg, rightLeg);

    // head (elongated)
    const head = new THREE.Mesh(new THREE.ConeGeometry(0.35, 0.9, 8), new THREE.MeshStandardMaterial({ color:0x1f1f1f }));
    head.position.set(0, 2.05, 0.05);
    head.rotation.x = Math.PI;
    g.add(head);

    // antler-like horns (spikes)
    for (let i=-1;i<=1;i+=2){
      for (let j=0;j<3;j++){
        const horn = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.5, 4), new THREE.MeshStandardMaterial({ color:0x3a3a3a }));
        horn.position.set(i*0.15 + j*0.05*i, 2.45 + j*0.08, 0.2 - j*0.06);
        horn.rotation.z = i*0.3 + j*0.05*i;
        g.add(horn);
      }
    }

    // subtle ears/spikes
    const spike = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.2,0.02), new THREE.MeshStandardMaterial({ color:0x2a2a2a }));
    spike.position.set(0.45,2.15,0.03); spike.rotation.z = 0.6; g.add(spike.clone());
    spike.position.set(-0.45,2.15,0.03); spike.rotation.z = -0.6; g.add(spike.clone());

    // eyes (glow)
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffe6a7 });
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05,8,6), eyeMat); eyeL.position.set(-0.12,2.08,0.35);
    const eyeR = eyeL.clone(); eyeR.position.x = 0.12;
    g.add(eyeL, eyeR);

    // scale and hitbox
    g.scale.set(1.2, 1.2, 1.2);
    g.userData = { speed: 1.8, state: 'idle', health: 100 };

    return g;
  }

  const wendigos = new THREE.Group();
  scene.add(wendigos);

  // spawn a few wendigos at varied distances
  for (let i=0;i<2;i++){
    const w = buildWendigo();
    const angle = Math.random()*Math.PI*2;
    const r = 18 + Math.random()*40 + i*20;
    w.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
    w.rotation.y = Math.random()*Math.PI*2;
    wendigos.add(w);
  }

  // Ambient node to detect if player is seen: rudimentary LOS
  const raycaster = new THREE.Raycaster();

  // status UI update
  const statusEl = document.getElementById('status');
  function setStatus(s, color='#f88'){ statusEl.textContent = 'Status: ' + s; statusEl.style.color = color; }

  // Jumpscare flash overlay
  const flash = document.getElementById('flash');
  function doFlash() {
    flash.style.opacity = '1';
    setTimeout(()=> flash.style.opacity = '0', 120);
  }

  // simple footsteps: create a periodic pulse when moving
  let lastStep = 0;
  function footstep(now) {
    if (now - lastStep < 400) return;
    lastStep = now;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.value = 120 + Math.random()*80;
    g.gain.value = 0.03;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.08);
  }

  // Update wendigo AI: wander -> investigate -> chase
  const tmpVec = new THREE.Vector3();
  function updateWendigos(dt, time){
    const playerPos = controls.getObject().position;
    wendigos.children.forEach((w)=>{
      const data = w.userData;
      const toPlayer = tmpVec.subVectors(playerPos, w.position);
      const dist = toPlayer.length();
      // line of sight: cast a ray from w toward player to check if trees block (approx)
      raycaster.set(w.position.clone().add(new THREE.Vector3(0,1.2,0)), toPlayer.clone().normalize());
      const intersects = raycaster.intersectObjects(trees.children, true);
      const blocked = intersects.length > 0 && intersects[0].distance < dist;
      if (dist < 10 && !blocked) {
        data.state = 'chase';
      } else if (dist < 22 && !blocked) {
        data.state = 'investigate';
      } else {
        data.state = 'wander';
      }

      if (data.state === 'wander') {
        setStatus('Exploring', '#9f9');
        // slow wandering
        w.userData.wanderTime = (w.userData.wanderTime || 0) - dt;
        if (!w.userData.wanderTarget || w.userData.wanderTime <= 0) {
          const ang = Math.random()*Math.PI*2;
          const r = 8 + Math.random()*40;
          w.userData.wanderTarget = new THREE.Vector3(Math.cos(ang)*r, 0, Math.sin(ang)*r);
          w.userData.wanderTime = 4000 + Math.random()*8000;
        }
        // move a bit
        const dir = w.userData.wanderTarget.clone().sub(w.position);
        dir.y = 0;
        if (dir.length() > 0.2) {
          dir.normalize();
          w.position.addScaledVector(dir, dt*0.0003 * (0.6 + Math.random()*0.8) * 100);
          w.lookAt(w.position.clone().add(dir));
        }
      } else if (data.state === 'investigate') {
        setStatus('Sensing something...', '#ffcf66');
        // turn toward player slowly
        const dir = toPlayer.clone().normalize();
        w.lookAt(playerPos.x, w.position.y + 1.0, playerPos.z);
        w.position.addScaledVector(dir, dt*0.0005 * data.speed * 100);
      } else if (data.state === 'chase') {
        setStatus('Chase!', '#ff6666');
        // chase faster
        const dir = toPlayer.clone().normalize();
        w.lookAt(playerPos.x, w.position.y + 1.0, playerPos.z);
        w.position.addScaledVector(dir, dt*0.0016 * data.speed * 100);

        // if close enough -> game over / jumpscare
        if (dist < 1.6) {
          // trigger jump scare
          doFlash();
          setStatus('Eaten by Wendigo! Reload to try again', '#ff0000');
          controls.unlock();
          // freeze further movement
          canMove = false;
        }
      }
    });
  }

  // Basic collision: don't fall through ground; keep camera above ground (y)
  function keepPlayerAboveGround(){
    const pos = controls.getObject().position;
    if (pos.y < 1.6) pos.y = 1.6;
    // simple obstacle avoidance: don't let player go too close to a tree trunk
    trees.children.forEach(t=>{
      const d = Math.hypot(pos.x - t.position.x, pos.z - t.position.z);
      if (d < 0.9 * (t.scale.x)) {
        // push back
        const push = new THREE.Vector3(pos.x - t.position.x, 0, pos.z - t.position.z).normalize().multiplyScalar(0.02);
        pos.add(push);
      }
    });
  }

  // Resize handling
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Main loop
  let prev = performance.now();
  function animate(now){
    const dt = now - prev; prev = now;
    swayTrees(now);

    // movement update only when controls locked
    if (controls.isLocked && canMove) {
      const dir = new THREE.Vector3();
      if (move.forward) dir.z -= 1;
      if (move.back) dir.z += 1;
      if (move.left) dir.x -= 1;
      if (move.right) dir.x += 1;
      if (dir.length() > 0) {
        dir.normalize();
        // camera's rotation to world
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();
        const worldMove = new THREE.Vector3();
        worldMove.addScaledVector(forward, -dir.z);
        worldMove.addScaledVector(right, dir.x);
        worldMove.normalize();
        controls.getObject().position.addScaledVector(worldMove, speed * dt/1000);
        footstep(now);
      }
      keepPlayerAboveGround();
    }

    updateWendigos(dt, now);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // Minimal helpful UI: spawn a flashlight toggle and toggle wind intensity
  const stat = document.getElementById('status');
  const addControls = ()=> {
    const c = document.createElement('div');
    c.style.position = 'absolute'; c.style.left='12px'; c.style.bottom='12px'; c.style.zIndex = 10; c.style.color = '#cfc'; c.style.fontSize='13px';
    c.style.background='rgba(0,0,0,0.35)'; c.style.padding='8px'; c.style.borderRadius='8px';
    c.innerHTML = `
      <div>Controls: <b>WASD</b> move · <b>Mouse</b> look</div>
      <div style="margin-top:6px">
        <button id="windBtn">Toggle wind</button>
        <button id="flashBtn">Simulate scare</button>
      </div>`;
    document.body.appendChild(c);
    document.getElementById('windBtn').onclick = ()=>{
      wind.gain.gain.value = wind.gain.gain.value > 0.01 ? 0.0 : 0.06;
    };
    document.getElementById('flashBtn').onclick = ()=> doFlash();
  };
  addControls();

  // place invisible "player" object for other calculations
  controls.getObject().position.set(0,1.6,0);
  // center camera physically in scene
  renderer.domElement.style.cursor = 'crosshair';

  // quick keyboard for teleport: press T to random teleport (for fun)
  document.addEventListener('keydown', (e)=>{
    if (e.code === 'KeyT') {
      const r = 6 + Math.random()*60;
      const a = Math.random()*Math.PI*2;
      const x = Math.cos(a)*r, z = Math.sin(a)*r;
      controls.getObject().position.set(x, 1.6, z);
      setStatus('Teleported', '#9ff');
    }
  });

  // small helper to show debug positions on click (optional)
  renderer.domElement.addEventListener('dblclick', (ev)=>{
    const p = controls.getObject().position;
    console.log('Player pos', p.x.toFixed(2), p.y.toFixed(2), p.z.toFixed(2));
  });

  // initial camera orientation - look slightly forward
  camera.rotation.order = "YXZ";
  </script>
</body>
</html>
